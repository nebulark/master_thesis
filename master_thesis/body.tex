\subsection{Search Terms}
portal
3D lense
magic lense
Seams

dual depth buffer
Walkthrough applications
\section{Introduction}

\section{Literatur}

\subsection{Portals as Occlusion Culling}
potentially visible set
\cite{luebke:1995:portals}
\cite{yang:2014:walkthrough}

\subsection{Portals Algorithms History}


Portal Rendering in SEAMS (\cite{schmalstieg:1999:sewing})

Complex Portal rendering. (I use the same near Buffer technique) \cite{ lowe:2005:technique}


\url{https://th0mas.nl/2013/05/19/rendering-recursive-portals-with-opengl/}
\subsection{Portal Applications}

\subsubsection{Magic Lense}
\cite{viega:1996:3d}


\subsubsection{VR Interaction 3D Lenses}
\cite{borst:2009:real}
3D lenses which change, the properties. E.g. other rendered objects (x ray lense), inverted colors, fish eye effect.

\subsubsection{Navigation}
Portal Rendering in SEAMS (\cite{schmalstieg:1999:sewing})
\cite{pausch:1995:navigation} navigation with hand held minatures


\subsubsection{Game Mechanik}
Portal, Antichamber, Splitgate Warfare Arena

\subsubsection{VR Movement}

Portal Locomotion in Budget Cuts\url{https://www.youtube.com/watch?v=f786ak3GKQo}

\subsubsection{Fit More Space in Less Space}

\subsubsection{Space Division}
Rooms are split by portals. For each portal only the objects in its room need to be drawn.
\cite{ lowe:2005:technique}

\subsection{Graphics Programming}


\subsubsection{Raytracing}
software,
gpu,
NVIDIA RTX cards, Ray shaders?

\subsubsection{Rasterization}

\subsubsection{GPU Synchronisation}

\subsubsection{Uniforms / Storage Buffer Objects}

\subsubsection{Shaders / (Vulkan-) GLSL / SPIR-V}
branching, fragment discard, early stencil / depth, force early test, Stencil Export

\subsubsection{Occlusion Queries}

\subsubsection{OpenGL}
History

\subsubsection{Vulkan Overview}
input attachments, tile renderers,

(Sub-)Renderpass, Push Constants, Validation Layers, Pipelines, Dynamic state,

Molten VK-Framwork

\subsubsection{Depth / Stencil Test}
Limitations, common uses
Early Z! Fragment discard
Z Fighting,
Depth Formtas
inverse depth buffer with floating point is magic!

combined depth / stencil
\url{https://developer.nvidia.com/content/depth-precision-visualized}


\subsubsection{Instanced Drawing}

\section{Implementation}

\subsection{Software Raytracing}
Even after optimizing, very unlikely to be realtime suitable. 

Include statistics

\subsection{Why Vulkan}
Cross plattform with MoltenVK (apple deprecated openGL)
(Probably) More possibilities due to more explicit compared to OpenGL
More Potential to optimize
Learn effect
Stateless
Validation layers

\subsection{Rendertargets vs Stencil}

\subsection{Generating Camera Matrices}
Explain with images
\subsubsection{Initial Approach}
\subsubsection{Current Approach}

\subsubsection{Further work}
Could be improved. The work to calculate the matrices scales super linear. X^{N}, where X is the portal count and N is the number of iterations. With the use of potentially visible sets, we could dicard combinations which won't be used, reducing the time to calculate the matrices. However, this finding the correct matrix more difficult.


\subsection{Stencil Values}
Problem, value to set stencil must be also be used to compare

use prefixing and compare masks, lessens number of values
start at 1 to avoid ambiguities -> needs more bits, especially problematic for 2 and 4 Portals, which require one more bit than normal.




\subsection{Portal Definition}
Portals are defined as 2 Objects/Endpoints which share a mesh. The both endpoint may have any transformation. From those two endpoints, two teleportation matrices are generated, which when applyied move an object from one end point to the other.

Instead of an mesh representation, other representations, could have been used. E.g. A spehre which is defined by a mathematical equation.

\subsection{Near Buffer}
For only one planar portals a clip plane could work. However we are rendering multiple portals, which are not neccesarily planes.


\subsection{portal z fighting}
when rendering a portal, it is easily z fights with its partner portal, as it would render directly in it. To avoid this we store the winding order as the sign in our rendered depth.  depth is nearly equal and winding order is the same, we have exactly the previously mentionend case and need to discard the fragment. This is easily done by incrasing the comparisions value by some small amout or percentage.

\subsection{Portal Rendering Naive Approach}
One pass per per portal

\subsubsection{Portal drawing orderer Depth first vs breadth first}

breadth first seems better as we only need to clear depth buffer after each layer, because
each draw in a layer will never rendert to the same pixel as another draw in that layer
breadth first allows us to reduce pipelinecount if we use dynamic stencil ref and stencil compare mask

breadth first is easier to stop at a layer

depth first might b

\subsection{Initial Portal Rendering}
In subsequent draws, perform stencil test as well as test against "rendered depth" (similar to clip plane used in Portal 2).
We can force early depth/stencil as we never draw a pixels if it failes the test. We only maybe discard it if the test succeds.

Use pushconstant to decide camera index
clear depth between iterations
use dynamic stencil ref and stencil compare mask, to cut down number of pipelines drastically. Might not be optimal?


\subsubsection{Properties}
fixed number of portals, scales poorly
stencil values known at compile time
Not flexible
Very limited amout of portals an recursions

\subsection{Dynamic Portal Rendering}
Camera matrices are not accessed directly. Instead an an array is accessed which stores the id. Allows to dynamically change camera matrices
Invalid ids means we can skipp that draw -> Set all values in vertex shader to same value to create a degenerate triangle, to improve performance.
Calculate portal Id, dicard if portal id is greater than visible portals
Use portal Id to generate stencil value and the camera id.


\subsubsection{Visible Portal Number algorithm}
in fragmentshader: counter, traverse array, increase for non zeros, ignore at index corresponding to the current portal
write own number or 1 at the ignored location -> Multiple writes of same value should be save, accross "threads", when counting this is skipped so we have no reader at the moment
Needs synchornisation so that value is visible for the next portal!
-> Pseudo occlusion query with immediate result.
-> very conservatic. Portals totaly occluded by later portals or discarded by stencil test still counts as "visible". We can't check for stencil failure, as we can't access the stencil buffer.
-> depth prepass could mitigate this

\subsubsection{Occlusion query alternative}
probably slow
needs to process portals and then again with the result
probably needs some extra throwaway texture

\subsubsection{Properties}
fixed number of visible portals in each portal, which can be dynamic for recursion. E.G inital 4 visible portals, but in each of those only 2 visible portals
Number can be changed at runtime.
Even if visible portal count is too high, we can at least only produce degenerate triangles to save performance.

Requires stencil export (!). Not supported on nvidia cards (source: \url{https://vulkan.gpuinfo.org/listdevices.php?platform=windows&extension=VK_EXT_shader_stencil_export})
No early test for Portal rendering, as we are using stencil export.

\subsubsection{Opportunity: Dynamic Visible Portals count}
If we can detect the initial pass only has few visible portals (e.g. via frustrum culling like techniques), we lower the amount for the initial rendering, and increase it for
the subsequent pass.

Handles case of directly standing in front of a portal!
Have not implemented this

\subsection{Dynamic Portal instance rendering}
We render objects for each rendered portal of previous pass. Only difference is stencil value and camera index.
Camera Index can be calculated with InstanceIndex
Can't change stencil during instance drawing -> Drop Stencil Test. Use extra texture an perform it manually in shader, similar to rendered depth test. 

\subsubsection{Properties}
No early test for Scene.
Recursion and Portal count is only limited by performance, as we can use any number of bits for our test.
Number of draw calls now scales linearly with recursion count (although actuall draw count remains the same).
No Need for Stencil prefixes -> simplifies code, saves bits

Huge Performance Improvement!!! Was 6 times fast in my case. 
(should I measure this and create diagram?)

\subsubsection{Opportunity: Draw Indirect}
Using draw Indirect allows us to only use one draw call per pass, instead of one per object!
Additionally we can manipulate the draw indirect buffer, while calculating the portal id, so that the instance count matches the amount of actually drawn portals.
This way instead of producing degenerate triangles, we don't even draw meshes.
However, could be problematic as we would need to set each value in the shader, having a loop for each scene element, and many writes.

The conditional execution extension could be used (VK\_EXT\_conditional\_rendering) but only to disable drawing entirely, if no portal is rended -> probably not useful.

\subsubsection{Skip instances}
One downside is, that draw instanced draws the object for each portal. However sometimes would could know, that the object is not visible from a specific Portal, e.g. via Potentially visible set tests, or knowing by other means that the portal will never draw that object (e.g. diffrent world layers).
To combat this problem, we could decrease the draw instances count and provide iformation which portals should be skipped.

Instead of using instanceId directly, this skip information will be used to calculate the real id. The rest would behave the same, just using this genreated id instead of instanceId directly.


\subsection{Portal Collision}
On portal collision we apply the same operation on the camera, that would be applied to an object rendered through that portal.
It is implemented by storing a matrix of cumulative portal teleport matrices.
However, it is also possible to apply only a part of it for some interesting effects, but it will result in non seamless translation.

\subsection{Collision Detection (??)}
Raytrace with triangles (could be improved)
KD trees
Surface area heuristic

\subsection{Player Rendering}
When looking through a portal, players might see themselves. Care must be taken when rendering. Standing directly in fron of the portal and touching it slightly could make the player see their only model at their own location. (see valve talk \url{https://www.youtube.com/watch?v=riijspB9DIQ})

\subsection{Watertight Portals}
Objects behind watertight portals, will look as though that portal did not exist. Portals inside on endpoint of an watertight portals, will be visible when looking at the other endpoint, with the teleportation matrix applied. If watertight portals are static, they are essentially useless. The same scene could have been created without them.
However if they change or are created during runtime they can have interesting effects. Such as Scaling objects, or swapping two areas.

\subsection{Face Culling}
Appying face culling only works if no portal changes the scale of an object. Otherwise the triangle order gets changed too and wrong side will be rendered.

\subsection{Level Editor}
Ideally a custom level editor should be built, so the effect of the portals can be seen immediately. However, there was not enough time. After looking for various solution, using the unreal engine seemed best, as the author has some experience with it.

The UE4 Level editor is very convenient and can be customized. The level is exported with a Editor Script. However, some care must be taken as UE4 has a different coordinate system. For Vectors Y and Z must be swapped. For Quaternions, y and z must be swapped and the imaginary part inverted, as we are changing handedness.


\section{Further Work}
\subsection{More than just transforms}
\label{more than transforms}
The current approach uses camera indices, to decide which camera matrix gets applied. However, this approach is not limited to only changing matrices. Inspired by \cite{borst:2009:real} indices could be used to change other paramteres. We could add objects that only render if specific parameters are set, mark pixels for a later post process. Or take as specific branch in any shader.

\subsection{Non-Translating Portals}
The implemented portals have two endpoints. Objects Touch on endpoint, get move to the other. However, it is also possible that the portals don't move the object. In this case there are no two end points. It is just one portal.

Entering the portal would apply one operation (e.g. multiplying by matrix), leaving it applies the inverse operation. Back and Frontface detection needs to be used to decide which operation to apply.


This only works for operations which don't move the possition of an object, unless it is just an rotation and the portal shape looks the same after applying the rotation to it. E.g. a sphere could allow for any rotation. A cube only for rotation in intervals of 90 degrees.
Changing the scale of an objects would also work, but it is important, the the origin remains a the same position. However, this would result in non seamless portal transitions.

Furthermore, more than just transform can be applied. Operations described in the section \ref{more than transforms} would also work.

\subsection{Transparent Objects}
\subsection{Shadows}
Without currect handling, we can see portal locations, as shadows would be cut of.
\subsection{lighting}
Without correct lighting seams would be visible. Proabably very difficult for spot/pointlights. Directional light already works.
\subsection{Collision Detection}
\subsection{Use the Instant Occlusion query in occlusion culling}
we can set conditional rendering paramters during this occlusion culling.
Needs some  recursive portal passes and then one big scene pass, which makes use of conditional rendering, eitehr with the extension or draw indirect and instance counts. Inspired by \cite{yang:2014:walkthrough}












